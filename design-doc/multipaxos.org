- MultiPaxos
  # The Paxos module that contains the consensus logic for phase1 and phase2 of
  # the MultiPaxos protocol.

  - members

    - running_: atomic<bool>; a flag used by long-running threads (heartbeat
      thread and prepare thread) to know when to stop running; initialized to
      false, set to true with the start() method and to false with the
      shutdown() method.

    - id_: int64_t; identifier of this peer. initialized from the configuration
      file. currently, we limit the number of peers to 16; therefore, id_ is a
      value in [0, 16).

    - port_: string; the port where the RPC server is listening

    - ballot_: int64_t; current ballot number known to the peer;
      initialized |max_num_peers_|, which indicates that there is no current
      leader, since valid leader ids are in [0, max_num_peers_). it is a 64-bit
      integer, the lower 8 bits of which is always equal to |id_| of the peer
      that chose |ballot_|, and the higher bits represent the round number. we
      preserve 8 bits for |id_| but limit |id_| to 4 bits to avoid an overflow
      when identifying a leader. initialized to |id_|. at any moment, we can
      look at the lower 8 bits of |ballot_| to determine current leader.

    - log_: Log; a non-owning pointer to Log instance.

    - peers_: array of RPC endpoints; RPC endpoints to peers, including to self.
      initialized from the configuration file.

    - ready_: boolean; when a new leader is elected, it receives logs from the
      peers in the quorum; the leader merges all these logs to obtain the most
      up-to-date instance at each index in the log and then replays (calls
      accept on) all the instances in the merged log. for now, we consider the
      leader not ready to accept new requests from the clients until it has
      processed the merged log; the |ready_| flag tracks the readiness for
      accepting commands from clients. initialized to false.

    - last_heartbeat_: timestamp; timestamp of the last heartbeat received from the current
      leader. initialized to 0.

    - heartbeat_pause_: milliseconds; pause duration between heartbeats.
      initialized from the configuration file.

    - rpc_peers_: stubs to RPC peers; initialized based on the configuration file

    - rpc_server_: an RPC server for handling incoming RPC requests; initialized
      based on the configuration file

    - mu_: mutex; MultiPaxos is a concurrent object -- multiple threads may
      concurrently call its |decide| method. |mu_| protects shared data in
      MultiPaxos.

    - cv_leader_: condition variable; long-running threads (heartbeat_thread and
      prepare_thread) sleep on this condition variable to get notified when this
      peer becomes a leader.

    - tp_: thread_pool; a thread pool to which we post RPC requests to peers;
      initialized from the configuration file.

    - heartbeat_thread_: thread; runs the function heartbeat_thread() until
      shutdown() is called.

    # the followings are heartbeat thread related variables. we cannot make them
    # local to the heartbeat thread because the heartbeat thread posts tasks to
    # the threadpool tp_; it is possible that the threads from the threadpool
    # outlive the heartbeat thread, and if these variables are local to the
    # heartbeat thread, then the threadpool threads will end up referencing
    # destroyed variables. One other possible solution is to have the threadpool
    # local to the heartbeat thread as well.

    - heartbeat_request_: heartbeat RPC request protobuf; initialized every time
      right before heartbeats are sent by acquiring mu_ and getting a consistent
      set of its fields (ballot, last_executed, and global_last_executed) from
      this peer.

    - heartbeat_num_responses_: int; number of heartbeat responses; initialized
      to 0 every time right before heartbeats are sent.

    - heartbeat_ok_responses_: array of ints; the values of ok responses to
      heartbeats; reset to empty every time right before heartbeats are sent.

    - heartbeat_mu_: mutex; serializes access to heartbeat_num_responses_ and
      heartbeat_ok_responses_ among thread pool threads and the heartbeat
      thread.

    - heartbeat_cv_: condition variable; the heartbeat thread waits on this
      condition variable and it is woken up every time an RPC posted by a
      threadpool thread completes and signals this condition variable.

  - constants

    - id_bits_ = 0xff: the lower bits of |ballot_| we use for storing the id of
      the current leader.

    - round_increment_ = id_bits_ + 1: we add this constant to |ballot_| to
      increment the round portion of |ballot_| by one.

    - max_num_peers_ = 0xf: maximum number of peers.

  - types

    - heartbeat_rpc_request
      - ballot_: ballot of the leader sending the heartbeat RPC
      - last_executed_: last_executed_ of the leader sending the heartbeat RPC
      - global_last_executed_: global_last_executed of the leader sending the heartbeat RPC
    - heartbeat_rpc_response
      - last_executed_: last_executed_ of the follower responding to the
        heartbeat RPC

  - methods

    - constructor(log: *Log, cfg: config)
      running_ = false
      id_ = config["id"]
      port_ = config["peers"][id_]
      ballot_ = max_num_peers_
      log_ = log
      instantiate RPC stubs to each peer including self
      instantiate RPC server

    - start()
      # starts all the threads of the peer: RPC server threads, heartbeat
      # threads, prepare threads. a multipaxos instance on which start() was
      # called, must have a corresponding shutdown() call for a graceful
      # shutdown; conversely, if start() wasn't called, then shutdown() must not
      # be called.
      running_ = true
      heartbeat_thread_ = thread(heartbeat_thread()) # start heartbeat thread
      rpc_server_->wait() # start the RPC server so it listens for incoming calls

    - shutdown()
      running_ = false
      cv_leader_.notify_all()
      heartbeat_thread_.join()
      rpc_server_->shutdown() # stop the RPC server

    - next_ballot() -> int
      # description: gets the next ballot number by incrementing the round
      # portion of |ballot_| by |round_increment_| and setting the |id_| bits to
      # the id if this peer, since |ballot_| could have been generated by
      # another peer. calling this method makes this peer the leader, which is
      # why we also signal the cv_leader_ condition variable to wake up the
      # long-running threads, heartbeat_thread and prepare_thread.
      # preconditions:
      # postconditions:
      mu_.lock() # unlocks on return
      ballot_ += id_bits_
      ballot_ = (ballot_ & ~id_bits_) | id_
      cv_leader_.notify_all()
      return ballot_

    - leader() -> int
      # description: returns current leader's id
      # preconditions:
      # postconditions:
      mu_.lock() # unlocks on return
      return ballot_ & id_bits_

    - is_leader() -> bool
      # description: returns true if this peer is leader
      # preconditions:
      # postconditions:
      mu_.lock() # unlocks on return
      return is_leader_lockless()

    - is_leader_lockless() -> bool
      # description: returns true if this peer is leader
      # preconditions: lock is not acquired
      # postconditions:
      return (ballot_ & id_bits) == id_

    - is_someone_else_leader() -> bool
      # description: returns true if we are not a leader and someone else is.
      # this cannot simply be !is_leader() because it's not necessarily the case
      # that if this peer is not leader, then someone else must be: at startup
      # there is no leader.
      # preconditions:
      # postconditions:
      mu_.lock() # unlocks on return
      id = ballot_ & id_bits_
      return id != id_ && id < max_num_peers_

    - heartbeat_handler(request: heartbeat_rpc_request)
      # description: handler for the heartbeat RPC
      # preconditions:
      # postconditions:

      mu_.lock() # unlocks on return
      if message.ballot_ >= ballot_:
        last_heartbeat_ = time::now()
        ballot_ = message.ballot_
        stale_rpc = false
        log_.commit_until(message_.last_executed_, ballot_)
        log_.trim_until(message_.global_last_executed)
      return heartbeat_rpc_response{last_executed_: log_.last_executed()}

    - heartbeat_thread()
      while (running_) {
        # wait until this peer is a leader
        mu_.lock()
        while (running_ && !is_leader_lockless())
          cv_leader_.wait(mu_);
        mu_.unlock()

        # this peer is a leader
        while (running_)
          heartbeat_num_responses_ = 0
          heartbeat_ok_responses_ = []

          mu_.lock()
          heartbeat_request_.set_ballot(ballot_)
          heartbeat_request_.set_last_executed(log_.last_executed())
          heartbeat_request_.set_global_last_executed(log_.global_last_executed())
          mu_.unlock

          for each peer p
            post a closure to a thread pool {
              status = p.Heartbeat(heartbeat_request_)
              heartbeat_mu_.lock()
              ++heartbeat_num_responses_
              if status.ok
                heartbeat_ok_responses_.push_back(status.response)
              heartbeat_cv_.notify_one()
            }
            heartbeat_mu_.unlock()

          heartbeat_mu_.lock()
          while (is_leader() && heartbeat_num_responses_ != peers_.size())
            heartbeat_cv_.wait(hb_mu)
          if heartbeat_ok_responses_.size() == peer_.size()
            global_last_executed = min(ok_responses)
            log_.trim_until(global_last_executed)
          heartbeat_mu_.unlock()

          sleep(heartbeat_pause_)
          if !is_leader()
            break

- unit tests

  - constructor
    - ensure that class members are initialized correctly.

  - next_ballot
    - ensure that unique and higher ballot numbers are generated by different
      paxos peers.

  - heartbeat_ignore_stale_rpc
    - ensure that stale RPCs (those with older than peer's ballot numbers) are
      ignored by the heartbeat RPC handler:

      1) in thread t0 start peer0 RPC server
      2) in thread main, call peer0.next_ballot twice
      3) in thread main, create a heartbeat RPC request and set its ballot to the
         result of calling peer1.next_ballot
      4) in thread main, invoke heartbeat RPC on peer0

      since peer1.next_ballot was called once, the ballot on the heartbeat RPC
      should be smaller than the ballot on peer0; therefore, the RPC request
      should be ignored and peer0 should remain the leader.

  - heartbeat_changes_leader_to_follower
    - start peer0 as a leader, and ensure that a valid RPC (those with higher
      than peer's ballot numbers) from peer1 changes the peer0 to follower and
      that peer0 considers peer1 to be the leader.

      1) in thread t0, start peer0 RPC server
      2) in thread main, call peer0_.next_ballot to make peer0 leader
      3) in thread main, create a heartbeat RPC request request0 and set its
         ballot to the result of calling peer1.next_ballot -- now peer1 is a
         leader with a higher ballot number than peer0, but peer0 does not yet
         know it.
      4) in thread main, send request0 to peer0
      5) ensure that peer0 is not a leader anymore and considers peer1 as the leader.

  - heartbeat_updates_leader_on_followers
    - start peer0, peer1, and peer2; initially they are not leaders. call
      peer0.next_ballot() and ensure that peer1 and peer2 now recognize peer0 as
      the leader. call peer1.next_ballot() and ensure that peer0 and peer2
      recognize peer1 as leader, and finally call peer2.next_ballot() and ensure
      that peer0 and peer1 recognize peer2 as the leader.

      1) in thread t0, call peer0.start()
      2) in thread t1, call peer1.start()
      3) in thread t2, call peer2.start()
      4) in thread main, call peer0_.next_ballot, sleep 2 heartbeat interval and
         check that peer0 is the leader and peer1 and peer2 recognize peer0 as
         the leader.
      5) in thread main, call peer1_.next_ballot, sleep 2 heartbeat interval and
         check that peer1 is the leader and peer0 and peer2 recognize peer1 as
         the leader.
      6) in thread main, call peer2_.next_ballot, sleep 2 heartbeat interval and
         check that peer2 is the leader and peer0 and peer1 recognize peer1 as
         the leader.
