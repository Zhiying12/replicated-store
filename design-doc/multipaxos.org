- MultiPaxos
  # The Paxos module that contains the consensus logic for phase1 and phase2 of
  # the MultiPaxos protocol.

  - members

    - id_: int64_t; identifier of this peer. initialized from the configuration
      file. currently, we limit the number of peers to 16; therefore, id_ is a
      value in [0, 16).

    - ballot_: atomic<int64_t>; current ballot number known to the peer;
      initialized |max_num_peers_|, which indicates that there is no current
      leader, since valid leader ids are in [0, max_num_peers_). it is a 64-bit
      integer, the lower 8 bits of which is always equal to |id_| of the peer
      that chose |ballot_|, and the higher bits represent the round number. we
      preserve 8 bits for |id_| but limit |id_| to 4 bits to avoid an overflow
      when identifying a leader. initialized to |id_|. at any moment, we can
      look at the lower 8 bits of |ballot_| to determine current leader.

    - log_: Log; a non-owning pointer to Log instance.

    - peers_: array of RPC endpoints; RPC endpoints to peers, including to self.
      initialized from the configuration file.

    - ready_: boolean; when a new leader is elected, it receives logs from the
      peers in the quorum; the leader merges all these logs to obtain the most
      up-to-date instance at each index in the log and then replays (calls
      accept on) all the instances in the merged log. for now, we consider the
      leader not ready to accept new requests from the clients until it has
      processed the merged log; the |ready_| flag tracks the readiness for
      accepting commands from clients. initialized to false.

    - last_heartbeat_: timestamp; timestamp of the last heartbeat received from the current
      leader. initialized to 0.

    - heartbeat_interval_: milliseconds; interval between heartbeats.
      initialized from the configuration file.

    - mu_: mutex; MultiPaxos is a concurrent object -- multiple threads may
      concurrently call its |decide| method. |mu_| protects shared data in
      MultiPaxos.

  - constants

    - id_bits_ = 0xff: the lower bits of |ballot_| we use for storing the id of
      the current leader.

    - round_increment_ = id_bits_ + 1: we add this constant to |ballot_| to
      increment the round portion of |ballot_| by one.

    - max_num_peers_ = 0xf: maximum number of peers.

  - types

    - heartbeat_rpc_request
      - ballot_: ballot of the leader sending the heartbeat RPC
      - last_executed_: last_executed_ of the leader sending the heartbeat RPC
      - global_last_executed_: global_last_executed of the leader sending the heartbeat RPC
    - heartbeat_rpc_response
      - last_executed_: last_executed_ of the follower responding to the
        heartbeat RPC

  - methods

    - constructor(log: *Log, cfg: config)

    - next_ballot() -> int
      # description: gets the next ballot number by incrementing the round
      # portion of |ballot_| by |round_increment_| and setting the |id_| bits to
      # the id if this peer, since |ballot_| could have been generated by
      # another peer. calling this method makes this peer the leader.
      # preconditions:
      # postconditions:
      mu_.lock()
      ballot_ += id_bits_
      ballot_ = (ballot_ & ~id_bits_) | id_
      return ballot_

    - leader() -> int
      # description: returns current leader's id
      # preconditions:
      # postconditions:
      return ballot_ & id_bits_

    - is_leader() -> bool
      # description: returns true if this peer is leader
      # preconditions:
      # postconditions:
      return leader() == id_

    - is_someone_else_leader() -> bool
      # description: returns true if we are not a leader and someone else is.
      # this cannot simply be !is_leader() because it's not necessarily the case
      # that if this peer is not leader, then someone else must be: at startup
      # there is no leader.
      # preconditions:
      # postconditions:
      id = leader();
      return id != id_ && id < max_num_peers_

    - heartbeat_handler(request: heartbeat_rpc_request)
      # description: handler for the heartbeat RPC
      # preconditions:
      # postconditions:

      stale_rpc = true
      mu_.lock()
      if message.ballot_ >= ballot_:
        last_heartbeat_ = time::now()
        ballot_ = message.ballot_
        stale_rpc = false
      mu_.unlock()

      # our log object is concurrent, so we don't need to hold the lock during
      # the whole RPC handling. instead, we introduce stale_rpc boolean that
      # is set to false when the lock is held and the ballots are compared.
      if !stale_rpc:
        log_.commit_until(message_.last_executed_, ballot_)
        log_.trim_until(message_.global_last_executed)
      return heartbeat_rpc_response{last_executed_: log_.last_executed()}

- unit tests

  - constructor
    - ensure that class members are initialized correctly.
