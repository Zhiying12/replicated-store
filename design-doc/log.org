- Log
  # We can think of Log as an unbounded producer-consumer queue. From this
  # perspective, the execute method acts as the consume method of a queue, and
  # the commit method acts as a produce method of a queue. Technically,
  # instances are inserted into the queue via the append method; however, they
  # do not become executable until they are committed by calling commit on the
  # instance. The Log is unbounded because the instances will usually be
  # executed quickly; therefore, wake up happens only one way: the thread that
  # commits wakes up the executor thread to execute instances.

  - types:

    log_t: a map from int to Instance

  - members

    - log_t: log

    - last_index_: index of the highest-numbered instance in the log. the log
      starts at index 1; therefore, last_index_ is initialized to 0, signifying
      an empty log.

    - last_executed_: index of the last executed instance. initialized to 0.

    - global_last_executed_: index of the last executed instance on all peers
      known to this peer. initialized to 0.

    - mu_: the mutex of the object that needs to be acquired before the object
      is modified.

    - cv_executable_: the condition variable on which the execute method sleeps
      and commit method signals.

    - cv_commitable_: the condition variable on which the commit method sleeps
      on rare occasions and append method signals

  - log invariants
    # given that (1) the instances in the log must be executed in order, (2)
    # last_executed_ is the index of the last executed instance, and (3)
    # global_last_executed_ is the index of the last instance that was executed
    # in all peers, our log has the following invariants:
    #
    # (i1) global_last_executed_ <= last_executed_
    # (i2) there is no gap in [global_last_executed_, last_executed_]; all are executed
    # (i3) there is no executed instance after last_executed_.
    # (i4) there are no instances at indices < global_last_executed_


  - non-members functions

    - insert(log: *log_t, instance: Instance) -> bool
      # description: given |log| and |instance|, inserts |instance| to |log| if
      # possible, and returns true if an instance was inserted to an empty slot;
      # also checks for safety violations.
      # precondition:
      # postcondition:

      # case (1): |log| doesn't have an instance at instance.index_, in which
      # case we simply insert the instance to |log|.
      i = instance.index_
      if log[i] == empty
        log[i] = instance
        return true

      # case (2): |log| has a committed/executed instance at |instance.index_|,
      # in which case insert should be a no-op, and the command in |log| should
      # match the command in |instance|.
      if log[i].state_ == (committed or executed)
        assert(log[i].command_ == instance.command_) << "case2"
        return false

      # case (3): |log| has an in-progress instance at |instance.index_|, in
      # which case insert should examine the ballot numbers of both instances.
      #
      # if |instance.ballot_| > |log[i].ballot_| insert replaces the instance
      # in |log| with |instance|.
      #
      # if |instance.ballot_| == |log[i].ballot_| it must be the case that
      # |instance.command_| == |log[i].command_| and insert is a no-op.
      #
      # if |instance.ballot_| < |log[i].ballot_| insert ignores instance because
      # it is stale.
      if instance.ballot_ > log[i].ballot_
        log[i] = instance
        return false

      if instance.ballot_ == log[i].ballot_
        assert(log[i].command_ == instance.command_) << "case3"

      return false

  - public methods

    - constructor()
      last_index_ = 0
      last_executed_ = 0
      global_last_executed_ = 0

    - last_executed(void) -> int
      acquire mu_ and release on exit
      return last_executed_

    - global_last_executed(void) -> int
      acquire mu_ and release on exit
      return global_last_executed_

    - advance_last_index(void) -> int
      acquire mu_ and release on exit
      return ++last_index_

    - append(instance: Instance)
      # description: appends an instance to the log; called from the
      # accept_handler.
      # precondition:
      # postcondition:

      * # case (1): instance.index is pruned from log
        #
        # append() must be a no-op when called it with an instance at an index
        # pruned from our log. this can happen in some rare and convoluted
        # scenarios in both call paths (c1) and (c2).
      mu_.lock()
      i = instance.index_
      if i <= global_last_executed_
        mu_.unlock()
        return

      if insert(&log_, instance)
        last_index_ = max(last_index_, i)
        cv_commitable_.notify_all()

    - commit(index_: int)
      # precondition: int > 0
      # sets the state of the instance at index to committed and possibly wakes
      # up the executor thread if the log is executable.

      * # commit is called exclusively by the leader, after it sends out accept
        # to all peers, including itself, and receiving ok responses from the
        # quorum. the accept handler in every peer inserts an instance into the
        # log and then responds with an ok if successful. most of the time, the
        # leader will immediately receive an ok from its own rpc handler before
        # receiving ok from the remote peers; therefore, by the time it calls
        # commit, it is likely to have an instance at the index_, and calling
        # commit is fine. in the rare cases when the leader receives ok
        # responses from remote peers before itself, we wait on the condition
        # variable that will eventually be signalled by append called from
        # accept_handler.
      mu.lock()
      while log_[index] == empty
        cv_commitable_.wait()

      * # when running prepare, we will ask peers, including ourselves, to send us
        # their log starting at their global_last_executed_ and merge it to our
        # log. then we will run accept on all instances starting after
        # global_last_executed_. hence, we may run accept on an instance that is
        # already committed or even executed in our log. our accept handler will
        # not touch log_ for such instances but it will respond with an accept
        # and eventually, we may run commit for such instances, in which case we
        # will end up here. for those instances, commit must be a no-op. hence,
        # we will only update an instances state to committed only if it is in
        # in-progress state.
      if log_[index_].state == in-progress
        log_[index_].state = committed

      # we must do this check every time because it may be an instance that we
      # merged into our log from a remote peer that was already in committed
      # state. in this case, we should wake up the thread to execute the
      # instance on our state machine.
      if (executable())
        cv_executable_.notify_one()
      mu_.unlock()

    - execute(kv: KVStore) -> (client-id, result)
      # As described above, this method acts as a consume method of a
      # producer/consumer queue. Therefore, it sleeps until it is woken up by
      # someone calling commit (i.e. produce) method of the queue. Once woken
      # up, it executes one instance, sets the state of the instance to
      # executed, increments last_executed_, and returns the result and the id
      # of the client that originated the command.
      mu_.lock()
      while not is_executable():
        cv_executable_.wait()

      instance = &log_[last_executed_+1]
      result = kv.execute(instance.cmd)
      ++last_executed_
      return (instance.client-id_, result)

    - commit_until(leader_last_executed: int, ballot: int)
      # called from the heartbeat handler after receiving last_executed from the
      # leader (i.e. leader_last_executed). sets the state of all the instances
      # from last_executed_ until leader_last_executed and wakes up the executor
      # thread if necessary.
      mu_.lock()
      for (int i = last_executed_ + 1; i <= leader_last_executed; ++i)
      * # we may receive a heartbeat before we receive the accept message;
        # therefore, the heartbeat handler may run this function while there
        # is a gap in the log. when we see a gap, we break out of the loop and
        # try committing the next time we receive heartbeat from the leader;
        # hopefully, by that time, we will have received the accept message
        # and the gap will disappear.
      if (log_[i] == empty)
        break

      * # |ballot| will determine whether we will commit instances in the log.
        # we can have three cases with respect to |ballot| and the ballot of
        # instances in the log after last_executed_:
        #
        # case (1) |ballot| is smaller: this is the impossible case because
        # commit_until is always called from the heartbeat_handler, which will
        # reject heartbeats with a lower ballot number than ours. we assert this
        # impossiblity below.
      assert(ballot >= log_[i].ballot_)

      * # case (2) they are equal: this is the common case. as a follower, we
        # will usually have in-progress instances in our log; we will
        # receive |leader_last_executed| that is larger than last_executed_,
        # and we will catch up by committing instances in our own log.
      if (log_[i].ballot_ == ballot)
        log_[i].state = committed

      * # case (3) |ballot| is larger: this is the uncommon case, and it can
        # happen as follows: (a) we experience a partition, (b) a new leader
        # emerges and establishes new commands for the instances that are
        # already in our log, and (b) we reconnect. in this scenario, we will
        # have stale commands in our log and we cannot commit them because it
        # will violate safety. in this scenario, we will do nothing and
        # return, and as a result, prevent global_last_executed_ from
        # advancing, until a new leader is elected, and it replays every
        # instance since global_last_executed_ and we discover the new
        # commands that we missed during the partition.

      if (executable())
        cv_executable_.notify_one()
      mu_.unlock()

    - trim_until(leader_global_last_executed: int)
      # called from the heartbeat handler after receiving global_last_executed
      # from the leader (i.e. |leader_global_last_executed|). removes all
      # instances in [global_last_executed_+1, leader_global_last_executed] from
      # the log_.

      while global_last_executed_ < leader_global_last_executed
        ++global_last_executed_
        # case (1): the following assertion follows from (i1) and (i2)
        assert(log_[global_last_executed_].state == executed)
        del log_[global_last_executed_]

    - instances_for_prepare() -> Instance[]
      # description: return instances for a response to a prepare message; these
      # are instances since global_last_executed_.
      # precondition:
      # postcondition:
      mu_.lock()
      instances = Instance[]
      for i = global_last_executed_ + 1; i <= last_index_; ++i
        if log_[i] != empty
          instances.append(log_[i])
      return instances

  - private methods:

    - is_executable(void) -> bool
      # preconditions: mu_ must be held

      # returns true if the log contains an executable instance, i.e. the
      # instance right after last_executed_ is committed.
      return log_[last_executed_+1] != empty &&
        log_[last_executed_+1].state == committed

  - test methods:
    # these methods are used only in unit tests

    - at(index: int) -> pointer to instance
      return a constant pointer to the instance

- unit tests

  - constructor
    - ensure that class members are initialized properly

  - insert
    - inserting a new instance in in-progress state returns true, and inserting
      an instance with the same ballot, command, and state at the same index, is
      a no-op and returns false

  - insert-update-in-progress
    - updating an in-progress instance with a higher ballot updates the instance
      and returns false

  - insert-update-committed
    - updating a committed instance is a no-op and returns false.

  - insert-stale
    - inserting a stale instance is a no-op returns false

  - insert-case2-committed (death test)
    - see case 2 in the description of insert

  - insert-case2-executed (death test)
    - see case 2 in the description of insert

  - insert-case3 (death test)
    - see case 3 in the description of insert

  - append
    - common case test: appended members appear in the log at correct indexes.

  - append-with-gap
    - if we leave a gap in the log by appending an instance at last_index_ + m,
      where m > 1, then last_index_ should be updated to last_index_ + m.

  - append-fill-gaps
    - if we leave a gap in the log by appending an instance at last_index_ + m,
      where m > 1, and then append an instance at k, where last_index_ < k < m,
      then last_index_ does not change because the append operation is filling a
      gap and not extending the log.

  - append-high-ballot-override
    - if log_[m] contains an instance with ballot = n and we append an instance
      at log_[m] with ballot = o, where o > n, then append should overwrite the
      instance in the log.

  - append-low-ballot-no-effect
    - if log_[m] contains an instance with ballot = n and we append an instance
      at log_[m] with ballot = o, where o < n, then append should have no
      effect.

  - commit
    - committing an instance should change its state to committed; if there is a
      gap between last_executed_ and committed instance, then the log should not
      become executable; otherwise, it should.

  - commit-before-append
    - committing an instance at the index that does not yet have an instance
      because append wasn't called yet (see commit function description above
      for when this can happen) should eventually succeed after append is
      called.

  - append-commit-execute
    - the common case of appending, committing, and executing an instance

  - append-commit-execute-out-of-order
    - append three instances in order, commit them in reverse order, and ensure
      that they are all executed.

  - commit-until
    - append instances at indexes 1, 2, and 3, and call commit_until with the
      same ballot number and leader_last_executed = 2, and ensure that instances
      1 and 2 are committed and 3 is not, and the log is executable.

  - commit-until-higher-ballot
    - append instances at indexes 1, 2, and 3, and call commit_until with a
      higher ballot number and leader_last_executed = 3, ensure that none of the
      instances committed and the log is not executable.

  - commit-until-case2 (death test)
    - see case 2 in the description of commit-until

  - commit-until-with-gap
    - append instances at indexes 1, 3, and 4, and call commit_until with the
      same ballot number and leader_last_executed = 4 and ensure that 1 is
      committed and 3 and 4 aren't, and the log is executable.

  - append-commit-until-execute
    - append instances at indexes 1, 2, and 3, and call commit_until with
      leader_last_executed = 3, and ensure that all instances are executed.

  - append-commit-until-execute-trim-until
    - append instances at indexes 1, 2, and 3, and call commit_until with the
      same ballot number and leader_last_executed = 3, and then call trim_until
      with leader_global_last_executed = 3, and ensure that all of the instances
      removed from the log.

  - append-at-trimmed-index
    - append instances at indexes 1 and 2, and call commit_until with the same
      ballot number and leader_global_last_executed = 2, and then call
      trim_until with leader_global_last_executed = 2 to move the
      global_last_executed_ to 2. append an instance at index 1 and 2 again and
      ensure that it has no effect, i.e. there are no instances at index 1
      and 2.
