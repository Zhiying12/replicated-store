- Log
  # We can think of Log as an unbounded producer-consumer queue. From this
  # perspective, the execute method acts as the consume method of a queue, and
  # the commit method acts as a produce method of a queue. Technically,
  # instances are inserted into the queue via the append method; however, they
  # do not become executable until they are committed by calling commit on the
  # instance. The Log is unbounded because the instances will usually be
  # executed quickly; therefore, wake up happens only one way: the thread that
  # commits wakes up the executor thread to execute instances.

  - members

    - log_: a map from int to an instance_t

    - last_index_: index of the highest-numbered instance in the log. the log
      starts at index 1; therefore, last_index_ is initialized to 0, signifying
      an empty log.

    - last_executed_: index of the last executed instance. initialized to 0.

    - global_last_executed_: index of the last executed instance on all peers
      known to this peer. initialized to 0.

    - mu_: the mutex of the object that needs to be acquired before the object
      is modified.

    - cv_executable_: the condition variable on which the execute method sleeps
      and commit method signals.

    - cv_commitable_: the condition variable on which the commit method sleeps
      on rare occasions and append method signals

  - log invariants
    # given that (1) the instances in the log must be executed in order, (2)
    # last_executed_ is the index of the last executed instance, and (3)
    # global_last_executed_ is the index of the last instance that was executed
    # in all peers, our log has the following invariants:
    #
    # (i1) global_last_executed_ <= last_executed_
    # (i2) there is no gap in [global_last_executed_, last_executed_]; all are executed
    # (i3) there is no executed instance after last_executed_.
    # (i4) there are no instances at indices < global_last_executed_

  - public methods

    - constructor()
      last_index_ = 0
      last_executed_ = 0
      global_last_executed_ = 0

    - last_executed(void) -> int
      acquire mu_ and release on exit
      return last_executed_

    - global_last_executed(void) -> int
      acquire mu_ and release on exit
      return global_last_executed_

    - advance_last_index(void) -> int
      acquire mu_ and release on exit
      return ++last_index_

    - append(instance: instance_t)
        # we call append() in two call paths:
        #
        # (c1) when we are a follower and we receive an accept message, we call
        #      append() in accept_handler()
        # (c2) when we are a leader candidate and we send out prepare request
        #      and receive logs from the quorum, we call append() in
        #      log_.merge() to merge the received logs.

      * # case (1): instance.index is pruned from log
        #
        # append() must be a no-op when called it with an instance at an index
        # pruned from our log. this can happen in some rare and convoluted
        # scenarios in both call paths (c1) and (c2).
      mu_.lock()
      i = instance.index_
      if i <= global_last_executed_
        mu_.unlock()
        return

      * # before we jump to the next case, now that we know the |instance| is
        # not stale, we need to see if it is in executed state and change it to
        # committed to preserve (i3). that's because in call path (c2) append
        # may be called with an instance in "executed" state: if we are a peer
        # that got partitioned and joined back, and we try to become a leader,
        # we will receive logs from other peers that have executed instances in
        # their logs. we need to reset the state of such instances back to
        # "committed" to ensure that such instances will be executed on our
        # state machine. we don't need to do anything to an instance that is in
        # in-progress or committed states: if it is committed, then it will
        # eventually get executed, or if it is in-progress, it will either be
        # committed or updated.
      if instance.state == executed
        instance.state = committed

      * # case (2): log_[instance.index_] is empty
        #
        # in that case, it must be that i > last_executed_ due to (i3); we
        # assert this, insert instance to log_, update last_index_, and notify
        # the cv_commitable_ to possibly wake up the commit thread and return.
      if log_[i] == empty
        assert(i > last_executed_)
        log_[i] = instance
        last_index_ = max(last_index_, i)
        cv_commitable_.notify_one()
        mu_.unlock()
        return

      * # case (3): log_[instance.index_] is committed/executed
        #
        # append() must be a no-op if we call it with an instance that is
        # already a committed or executed in our log; furthermore, |instance|'s
        # command must match the command in our log, *independent of
        # what |instance|'s state is*: if |instance|'s state is in-progress,
        # i.e. append() is being called in (c1), then it must have learned the
        # command from the quorum; if |instance|'s state is committed or
        # executed, i.e. append() is being called in (c2), then logs from other
        # peers must contain the same command.
      if log_[i].state_ == (committed or executed)
        assert(log_[i].command_ == instance.command_)
        mu_.unlock()
        return

      * # case (4): log_[instance.index_] is in-progress
        #
        # in this case, we should decide based on the value of ballot_; we only
        # consider the case of |instance|'s ballot being larger or equal to
        # log_[instance.index_]'s ballot. if instance's ballot is smaller than
        # the log_[instance.index_]'s ballot, we ignore it because it's stale.
        #
        # if log_[instance.index].ballot_ < instance.ballot_, we must update our
        # log because we may have a stale instance; such a scenario may happen
        # in (c2) when we receive a newer log from a peer.
        #
        # if log_[instance.index].ballot_ == instance.ballot_, it must be the
        # case that both instances have the same command. this may happen in
        # scenario (c1) when somehow we receive the same accept command twice.
      if log_[i].ballot_ < instance.ballot_
        log_[i] = instance
        mu_.unlock()
        return

      if log_[i].ballot_ == instance.ballot_
        assert(log_[i].command_ == instance.command_)
        mu_.unlock()
        return

    - commit(index_: int)
      # precondition: int > 0
      # sets the state of the instance at index to committed and possibly wakes
      # up the executor thread if the log is executable.

      * # commit is called exclusively by the leader, after it sends out accept
        # to all peers, including itself, and receiving ok responses from the
        # quorum. the accept handler in every peer inserts an instance into the
        # log and then responds with an ok if successful. most of the time, the
        # leader will immediately receive an ok from its own rpc handler before
        # receiving ok from the remote peers; therefore, by the time it calls
        # commit, it is likely to have an instance at the index_, and calling
        # commit is fine. in the rare cases when the leader receives ok
        # responses from remote peers before itself, we wait on the condition
        # variable that will eventually be signalled by append called from
        # accept_handler.
      mu.lock()
      while log_[index] == empty
        cv_commitable_.wait()

      * # when running prepare, we will ask peers, including ourselves, to send us
        # their log starting at their global_last_executed_ and merge it to our
        # log. then we will run accept on all instances starting after
        # global_last_executed_. hence, we may run accept on an instance that is
        # already committed or even executed in our log. our accept handler will
        # not touch log_ for such instances but it will respond with an accept
        # and eventually, we may run commit for such instances, in which case we
        # will end up here. for those instances, commit must be a no-op. hence,
        # we will only update an instances state to committed only if it is in
        # in-progress state.
      if log_[index_].state == in-progress
        log_[index_].state = committed

      # we must do this check every time because it may be an instance that we
      # merged into our log from a remote peer that was already in committed
      # state. in this case, we should wake up the thread to execute the
      # instance on our state machine.
      if (executable())
        cv_executable_.notify_one()
      mu_.unlock()

    - execute(kv: KVStore) -> (client-id, result)
      # As described above, this method acts as a consume method of a
      # producer/consumer queue. Therefore, it sleeps until it is woken up by
      # someone calling commit (i.e. produce) method of the queue. Once woken
      # up, it executes one instance, sets the state of the instance to
      # executed, increments last_executed_, and returns the result and the id
      # of the client that originated the command.
      mu_.lock()
      while not is_executable():
        cv_executable_.wait()

      instance = &log_[last_executed_+1]
      result = kv.execute(instance.cmd)
      ++last_executed_
      return (instance.client-id_, result)

    - commit_until(leader_last_executed: int, ballot: int)
      # called from the heartbeat handler after receiving last_executed from the
      # leader (i.e. leader_last_executed). sets the state of all the instances
      # from last_executed_ until leader_last_executed and wakes up the executor
      # thread if necessary.
      mu_.lock()
      for (int i = last_executed_ + 1; i <= leader_last_executed; ++i)
      * # we may receive a heartbeat before we receive the accept message;
        # therefore, the heartbeat handler may run this function while there
        # is a gap in the log. when we see a gap, we break out of the loop and
        # try committing the next time we receive heartbeat from the leader;
        # hopefully, by that time, we will have received the accept message
        # and the gap will disappear.
      if (log_[i] == empty)
        break

      * # |ballot| will determine whether we will commit instances in the log.
        # we can have three cases with respect to |ballot| and the ballot of
        # instances in the log after last_executed_:
        #
        # case (1) |ballot| is smaller: this is the impossible case because
        # commit_until is always called from the heartbeat_handler, which will
        # reject heartbeats with a lower ballot number than ours. we assert this
        # impossiblity below.
      assert(ballot >= log_[i].ballot_)

      * # case (2) they are equal: this is the common case. as a follower, we
        # will usually have in-progress instances in our log; we will
        # receive |leader_last_executed| that is larger than last_executed_,
        # and we will catch up by committing instances in our own log.
      if (log_[i].ballot_ == ballot)
        log_[i].state = committed

      * # case (3) |ballot| is larger: this is the uncommon case, and it can
        # happen as follows: (a) we experience a partition, (b) a new leader
        # emerges and establishes new commands for the instances that are
        # already in our log, and (b) we reconnect. in this scenario, we will
        # have stale commands in our log and we cannot commit them because it
        # will violate safety. in this scenario, we will do nothing and
        # return, and as a result, prevent global_last_executed_ from
        # advancing, until a new leader is elected, and it replays every
        # instance since global_last_executed_ and we discover the new
        # commands that we missed during the partition.

      if (executable())
        cv_executable_.notify_one()
      mu_.unlock()

    - trim_until(leader_global_last_executed: int)
      # called from the heartbeat handler after receiving global_last_executed
      # from the leader (i.e. |leader_global_last_executed|). removes all
      # instances in [global_last_executed_+1, leader_global_last_executed] from
      # the log_.

      while global_last_executed_ < leader_global_last_executed
        ++global_last_executed_
        # case (1): the following assertion follows from (i1) and (i2)
        assert(log_[global_last_executed_].state == executed)
        del log_[global_last_executed_]

    - merge(logs: vector<instance_t[]>)
      for log in logs
        for instance in log
          append(instance)

    - new_instances() -> instance_t[]
      # return instances since global_last_executed_

  - private methods:

    - is_executable(void) -> bool
      # preconditions: mu_ must be held

      # returns true if the log contains an executable instance, i.e. the
      # instance right after last_executed_ is committed.
      return log_[last_executed_+1] != empty &&
        log_[last_executed_+1].state == committed

  - test methods:
    # these methods are used only in unit tests

    - at(index: int) -> pointer to instance
      return a constant pointer to the instance

- unit tests

  - constructor
    - ensure that class members are initialized properly

  - append
    - common case test: appended members appear in the log at correct indexes.

  - append-executed
    - when an instance in executed state is appended to the log, its state
      should change to committed (see append description above for explanation)

  - append-with-gap
    - if we leave a gap in the log by appending an instance at last_index_ + m,
      where m > 1, then last_index_ should be updated to last_index_ + m.

  - append-fill-gaps
    - if we leave a gap in the log by appending an instance at last_index_ + m,
      where m > 1, and then append an instance at k, where last_index_ < k < m,
      then last_index_ does not change because the append operation is filling a
      gap and not extending the log.

  - append-high-ballot-override
    - if log_[m] contains an instance with ballot = n and we append an instance
      at log_[m] with ballot = o, where o > n, then append should overwrite the
      instance in the log.

  - append-low-ballot-no-effect
    - if log_[m] contains an instance with ballot = n and we append an instance
      at log_[m] with ballot = o, where o < n, then append should have no
      effect.

  - append-case3-committed (death test)
    - see case 3 in the description of append

  - append-case3-executed (death test)
    - see case 3 in the description of append

  - append-case4 (death test)
    - see case 4 in the description of append

  - commit
    - committing an instance should change its state to committed; if there is a
      gap between last_executed_ and committed instance, then the log should not
      become executable; otherwise, it should.

  - commit-before-append
    - committing an instance at the index that does not yet have an instance
      because append wasn't called yet (see commit function description above
      for when this can happen) should eventually succeed after append is
      called.

  - append-commit-execute
    - the common case of appending, committing, and executing an instance

  - append-commit-execute-out-of-order
    - append three instances in order, commit them in reverse order, and ensure
      that they are all executed.

  - commit-until
    - append instances at indexes 1, 2, and 3, and call commit_until with the
      same ballot number and leader_last_executed = 2, and ensure that instances
      1 and 2 are committed and 3 is not, and the log is executable.

  - commit-until-higher-ballot
    - append instances at indexes 1, 2, and 3, and call commit_until with a
      higher ballot number and leader_last_executed = 3, ensure that none of the
      instances committed and the log is not executable.

  - commit-until-case2 (death test)
    - see case 2 in the description of commit-until

  - commit-until-with-gap
    - append instances at indexes 1, 3, and 4, and call commit_until with the
      same ballot number and leader_last_executed = 4 and ensure that 1 is
      committed and 3 and 4 aren't, and the log is executable.

  - append-commit-until-execute
    - append instances at indexes 1, 2, and 3, and call commit_until with
      leader_last_executed = 3, and ensure that all instances are executed.

  - append-commit-until-execute-trim-until
    - append instances at indexes 1, 2, and 3, and call commit_until with the
      same ballot number and leader_last_executed = 3, and then call trim_until
      with leader_global_last_executed = 3, and ensure that all of the instances
      removed from the log.

  - append-at-trimmed-index
    - append instances at indexes 1 and 2, and call commit_until with the same
      ballot number and leader_global_last_executed = 2, and then call
      trim_until with leader_global_last_executed = 2 to move the
      global_last_executed_ to 2. append an instance at index 1 and 2 again and
      ensure that it has no effect, i.e. there are no instances at index 1
      and 2.
